package dnssec

import (
	"context"
	"github.com/miekg/dns"
	"github.com/nsmithuk/resolver/dnssec/doe"
)

func validateNegativeResponse(ctx context.Context, r *result) (AuthenticationResult, error) {

	qname := r.msg.Question[0].Name
	qtype := r.msg.Question[0].Qtype

	nsec := doe.NewDenialOfExistenceNSEC(ctx, r.zone.Name(), r.authority.extractNSECRecords())
	nsec3 := doe.NewDenialOfExistenceNSEC3(ctx, r.zone.Name(), r.authority.extractNSEC3Records())

	if !nsec.Empty() {
		if nameSeen, typeSeen := nsec.TypeBitMapContainsAnyOf(qname, []uint16{dns.TypeCNAME, qtype}); nameSeen && !typeSeen {
			r.denialOfExistence = NsecNoData
			return Secure, nil
		}

		if nsec.PerformQNameDoesNotExistProof(qname) {
			r.denialOfExistence = NsecNxDomain
			return Secure, nil
		}
	}

	if !nsec3.Empty() {
		// Check for a NODATA response on the QName.
		if nameSeen, typeSeen := nsec3.TypeBitMapContainsAnyOf(qname, []uint16{dns.TypeCNAME, qtype}); nameSeen && !typeSeen {
			r.denialOfExistence = Nsec3NoData
			return Secure, nil
		}

		/*
			https://datatracker.ietf.org/doc/html/rfc5155#section-8.7

			The validator MUST verify a closest encloser proof for QNAME and MUST
			find an NSEC3 RR present in the response that matches the wildcard
			name generated by prepending the asterisk label to the closest
			encloser.  Furthermore, the bits corresponding to both QTYPE and
			CNAME MUST NOT be set in the wildcard matching NSEC3 RR.


			https://datatracker.ietf.org/doc/html/rfc5155#section-3.1.2.1

			Note that the opt-out bit only relates to unsigned delegations,
			so we don't check for it here.
		*/

		optout, closestEncloserProof, nextCloserNameProof, wildcardProof := nsec3.PerformClosestEncloserProof(qname)

		// We'll support an opt-out only if the question was for DS records.
		if optout && qtype == dns.TypeDS {
			r.denialOfExistence = Nsec3OptOut
			return Secure, nil
		}

		// Check for a NODATA response on a wildcard (if that's the only thing needed for the response to be Secure).
		if closestEncloserProof && nextCloserNameProof && !wildcardProof {

			// If we got no wildcard (covered) proof, check if we have a NODATA wildcard (match) proof.
			if closestEncloser, _, ok := nsec3.FindClosestEncloser(qname); ok {
				if nameSeen, typeSeen := nsec3.TypeBitMapContainsAnyOf("*."+closestEncloser, []uint16{dns.TypeCNAME, qtype}); nameSeen && !typeSeen {
					wildcardProof = true
				}
			}
		}

		if closestEncloserProof && nextCloserNameProof && wildcardProof {
			r.denialOfExistence = Nsec3NxDomain
			return Secure, nil
		}

	}

	return Bogus, ErrBogusDoeRecordsNotFound
}
